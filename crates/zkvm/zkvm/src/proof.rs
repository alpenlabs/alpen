use arbitrary::Arbitrary;
use borsh::{BorshDeserialize, BorshSerialize};
use serde::{Deserialize, Serialize};

/// Validity proof generated by the `ZkVmHost`
#[derive(
    Debug, Clone, Serialize, Deserialize, BorshSerialize, BorshDeserialize, PartialEq, Eq, Arbitrary,
)]
pub struct Proof(Vec<u8>);

impl Proof {
    pub fn new(data: Vec<u8>) -> Self {
        Self(data)
    }

    pub fn as_bytes(&self) -> &[u8] {
        &self.0
    }

    pub fn is_empty(&self) -> bool {
        self.0.is_empty()
    }
}

impl From<Proof> for Vec<u8> {
    fn from(value: Proof) -> Self {
        value.0
    }
}

impl From<&Proof> for Vec<u8> {
    fn from(value: &Proof) -> Self {
        value.0.clone()
    }
}

#[derive(
    Debug, Clone, Serialize, Deserialize, BorshSerialize, BorshDeserialize, PartialEq, Eq, Arbitrary,
)]
pub struct PublicValues(Vec<u8>);

impl PublicValues {
    pub fn new(data: Vec<u8>) -> Self {
        Self(data)
    }

    pub fn as_bytes(&self) -> &[u8] {
        &self.0
    }

    pub fn is_empty(&self) -> bool {
        self.0.is_empty()
    }
}

impl From<PublicValues> for Vec<u8> {
    fn from(value: PublicValues) -> Self {
        value.0
    }
}

impl From<&PublicValues> for Vec<u8> {
    fn from(value: &PublicValues) -> Self {
        value.0.clone()
    }
}

#[derive(
    Debug, Clone, Serialize, Deserialize, BorshSerialize, BorshDeserialize, PartialEq, Eq, Arbitrary,
)]
pub struct ProofReceipt {
    pub proof: Proof,
    pub public_values: PublicValues,
}

/// Verification Key required to verify proof generated from `ZKVMHost`
#[derive(
    Debug,
    Clone,
    PartialEq,
    Eq,
    Default,
    Serialize,
    Deserialize,
    BorshSerialize,
    BorshDeserialize,
    Arbitrary,
)]
pub struct VerificationKey(Vec<u8>);

impl VerificationKey {
    pub fn new(data: Vec<u8>) -> Self {
        Self(data)
    }

    pub fn as_bytes(&self) -> &[u8] {
        &self.0
    }
}

/// An input to the aggregation program.
///
/// Consists of a [`ProofReceipt`] and a [`VerificationKey`].
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct AggregationInput {
    receipt: ProofReceipt,
    vk: VerificationKey,
}

impl AggregationInput {
    pub fn new(receipt: ProofReceipt, vk: VerificationKey) -> Self {
        Self { receipt, vk }
    }

    pub fn receipt(&self) -> &ProofReceipt {
        &self.receipt
    }

    pub fn vk(&self) -> &VerificationKey {
        &self.vk
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ProofType {
    Groth16,
    Core,
    Compressed,
}
