use anyhow::{ensure, Context, Ok, Result};
use serde::{de::DeserializeOwned, Serialize};
use serde_json::to_vec;
use snark_bn254_verifier::Groth16Verifier;
use sp1_sdk::{ProverClient, SP1ProofWithPublicValues, SP1PublicValues, SP1VerifyingKey};
use strata_zkvm::{Proof, VerificationKey, ZKVMVerifier};
use substrate_bn::Fr;

/// A verifier for the `SP1` zkVM, responsible for verifying proofs generated by the host
pub struct SP1Verifier;

// Copied from ~/.sp1/circuits/v2.0.0/groth16_vk.bin
// This is same for all the SP1 programs that uses v2.0.0
pub const GROTH16_VK_BYTES: &[u8] = include_bytes!("groth16_vk.bin");

impl ZKVMVerifier for SP1Verifier {
    fn verify(verification_key: &VerificationKey, proof: &Proof) -> anyhow::Result<()> {
        let proof: SP1ProofWithPublicValues = bincode::deserialize(proof.as_bytes())?;
        let vkey: SP1VerifyingKey = bincode::deserialize(&verification_key.0)?;

        let client = ProverClient::new();
        client.verify(&proof, &vkey)?;

        Ok(())
    }

    fn verify_with_public_params<T: DeserializeOwned + serde::Serialize>(
        verification_key: &VerificationKey,
        public_params: T,
        proof: &Proof,
    ) -> anyhow::Result<()> {
        let mut proof: SP1ProofWithPublicValues = bincode::deserialize(proof.as_bytes())?;
        let vkey: SP1VerifyingKey = bincode::deserialize(&verification_key.0)?;

        let client = ProverClient::new();
        client.verify(&proof, &vkey)?;

        let actual_public_parameter: T = proof.public_values.read();

        // TODO: use custom ZKVM error
        anyhow::ensure!(
            to_vec(&actual_public_parameter)? == to_vec(&public_params)?,
            "Failed to verify proof given the public param"
        );

        Ok(())
    }

    fn verify_groth16(
        raw_sp1_proof: &Proof,
        vkey_hash: &[u8],
        committed_values_raw: &[u8],
    ) -> Result<()> {
        let vk = GROTH16_VK_BYTES;

        let sp1_proof: SP1ProofWithPublicValues = bincode::deserialize(raw_sp1_proof.as_bytes())
            .context("Failed to deserialize SP1 Groth16 proof")?;

        let sp1_groth16_proof_bytes = hex::decode(
            &sp1_proof
                .proof
                .try_as_groth_16()
                .context("Failed to convert proof to Groth16")?
                .raw_proof,
        )
        .context("Failed to decode Groth16 proof")?;

        ensure!(
            sp1_proof.public_values.as_slice() == committed_values_raw,
            "Mismatch public values"
        );

        // Convert vkey_hash to Fr, mapping the error to anyhow::Error
        let vkey_hash_fr = Fr::from_slice(vkey_hash)
            .map_err(|e| anyhow::anyhow!(e))
            .context("Unable to convert vkey_hash to Fr")?;

        let committed_values_digest = SP1PublicValues::from(committed_values_raw)
            .hash_bn254()
            .to_bytes_be();

        // Convert committed_values_digest to Fr, mapping the error to anyhow::Error
        let committed_values_digest_fr = Fr::from_slice(&committed_values_digest)
            .map_err(|e| anyhow::anyhow!(e))
            .context("Unable to convert committed_values_digest to Fr")?;

        // Perform the Groth16 verification, mapping any error to anyhow::Error
        let verification_result = Groth16Verifier::verify(
            &sp1_groth16_proof_bytes,
            vk,
            &[vkey_hash_fr, committed_values_digest_fr],
        )
        .map_err(|e| anyhow::anyhow!(e))
        .context("Groth16 verification failed")?;

        if verification_result {
            Ok(())
        } else {
            Err(anyhow::anyhow!("Groth16 proof verification returned false"))
        }
    }

    fn extract_public_output<T: Serialize + DeserializeOwned>(proof: &Proof) -> anyhow::Result<T> {
        let mut proof: SP1ProofWithPublicValues = bincode::deserialize(proof.as_bytes())?;
        let public_params: T = proof.public_values.read();
        Ok(public_params)
    }

    fn extract_borsh_public_output<T: borsh::BorshSerialize + borsh::BorshDeserialize>(
        proof: &Proof,
    ) -> anyhow::Result<T> {
        let proof: SP1ProofWithPublicValues = bincode::deserialize(proof.as_bytes())?;
        let buffer = proof.public_values.as_slice();
        let output: T = borsh::from_slice(buffer)?;
        Ok(output)
    }
}

// NOTE: SP1 prover runs in release mode only; therefore run the tests on release mode only
#[cfg(test)]
mod tests {

    use num_bigint::BigUint;
    use num_traits::Num;
    use strata_zkvm::ProofWithMetadata;

    use super::*;

    #[test]
    fn test_groth16_verification() {
        let expected_output: u32 = 1;
        let vk = "0x00b01ae596b4e51843484ff71ccbd0dd1a030af70b255e6b9aad50b81d81266f";

        let raw_proof = include_bytes!("../tests/proofs/proof-groth16.bin");
        let proof: ProofWithMetadata =
            bincode::deserialize(raw_proof).expect("Failed to deserialize Groth16 proof");

        let vkey_hash = BigUint::from_str_radix(
            vk.strip_prefix("0x").expect("vkey should start with '0x'"),
            16,
        )
        .expect("Failed to parse vkey hash")
        .to_bytes_be();

        assert!(SP1Verifier::verify_groth16(
            proof.proof(),
            &vkey_hash,
            &expected_output.to_le_bytes()
        )
        .is_ok());
    }

    #[test]
    fn test_g16_verification() {
        let raw_proof_str = "030000004b000000000000003135303231303338333936353733333537303537363532333337373738363332343433333732383330393431393834333131343233373936323635353839323836363939333137363931304c00000000000000313031373532393832313639383933363639313931393035383032353936373038393131333336363837333238373537393638343434333432323731383531363139323933333531363033380002000000000000316561306635636435336630346639363433646566306233633166656137363535353761313135363432623939343261656637336131316537333364336438653134316635326165356132356234623562663731633930336663343235373531646639393166313234633533366132373862386162646363366663613832346232336138383032303731303431623430383166626161653061366334363335643162326465323239636539393166333037633262633437646533346335396464303736323765306164373463346635393361303366373166363534376266636634346563306662376131383766386635386161623263623062643464393839393230656636316535343564356336666139666430646131613366386632343363663830313762616466303033366232623736306264663566333332356436333031313361386163333830613038326334613434613731316636616561303732333732663837383733383566626137343866303261323938373537303465363862323438663766386233633764383863343531316439323935336665343935633832333835373764643165383864323739666364616635363839663138336331313162383435643833613832353239613964353336306330623336363062346666326661646338346134303966646361613138323337363232303966653232616288020000000000003165613066356364353366303466393634336465663062336331666561373635353537613131353634326239393432616566373361313165373333643364386531343166353261653561323562346235626637316339303366633432353735316466393931663132346335333661323738623861626463633666636138323462323361383830323037313034316234303831666261616530613663343633356431623264653232396365393931663330376332626334376465333463353964643037363237653061643734633466353933613033663731663635343762666366343465633066623761313837663866353861616232636230626434643938393932306566363165353435643563366661396664306461316133663866323433636638303137626164663030333662326237363062646635663333323564363330313133613861633338306130383263346134346137313166366165613037323337326638373837333835666261373438663032613239383735373034653638623234386637663862336337643838633435313164393239353366653439356338323338353737646431653838643237396663646166353638396631383363313131623834356438336138323532396139643533363063306233363630623466663266616463383461343039666463616131383233373632323039666532326162303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030306a2906ac6ec461c8cacd5b3557157f59317bd572e57bc8253975aaf5c5acb488030000000000000024010000000000000600000000000000737472617461e803000000000000000000000300000000000000f40100000000000000000000010000000000000020000000000000001ea7f6c7a924a1e722c09301a826cfd95b21b23a294cec5da3c0b5908e62e0c720000000000000001ea7f6c7a924a1e722c09301a826cfd95b21b23a294cec5da3c0b5908e62e0c7200000000000000037ad61cff1367467a98cf7c54c4ac99e989f1fbb1bc1e646235e90c065c565ba2000000000000000351714af72d74259f45cd7eab0b04527cd40e74836a45abcae50f92d919d988f0400000040000000000000001400ca9a3b000000000000000020000000000000000055041ccd102ed3fc51ecec79bb752e77606643e86ecac388e8ea3aedbf414e4000000001000000100300000095000000000000000000000000b562bd119e8dcb79de93a9a690a2cf4466fd3c8077802982a5e614e75489a515f30100000000000000000000000000000000000000000000dd099e76771f693bfe3f35931aecb9749a7519219a5f49d36dc953a4b17ebd6ff80100000000000000000000000000000000000000000000836ad7315c24a8ff5f94f89158154ba0acd326f7a6260484bc45dd7fae2d862db400000000000000000000008f137d9cda0a27cf6a5f634ce2a4859914575a36965b3333806ca8048166157500000000000000008e489bb6eb66dcc59e13f5e94e43975b7f6a4d9e551040a4e896ad7fb4c6463070a064c9bfb94aabd9f03c9280fc02aae4bacc9c75cf4304e589ff1b3e92252501000000000000006c41f8e1dfb194dea31dff470f66d6655d21ba8beb82c250b815721003755411836ad7315c24";
        let raw_proof_bytes = hex::decode(raw_proof_str).unwrap();
        let proof = Proof::new(raw_proof_bytes);
        let raw_proof: SP1ProofWithPublicValues = bincode::deserialize(proof.as_bytes()).unwrap();
        println!("{:?}", raw_proof);
    }
}
