use borsh::{BorshDeserialize, BorshSerialize};
use strata_l1_txfmt::SubprotocolId;

use crate::{AsmError, Mismatched, Subprotocol};

/// A single auxiliary input request from a subprotocol during preprocessing.
///
/// [`AuxRequest`] represents a request made by a subprotocol during its
/// [`pre_process_txs`](Subprotocol::pre_process_txs) phase. Each request
/// contains the subprotocol's ID and the raw data needed for auxiliary
/// processing. These requests are collected and eventually resolved into
/// [`AuxPayload`] entries that can be used during the main processing phase.
///
/// The `data` field contains the raw bytes that will be processed to generate
/// the corresponding auxiliary input data in the final [`AuxPayload`].
#[derive(Debug)]
pub struct AuxRequest {
    /// Which subprotocol this request belongs to.
    pub id: SubprotocolId,
    /// Raw data for the auxiliary input request.
    pub data: Vec<u8>,
}

/// A single subprotocol's auxiliary input payload, containing processed auxiliary data.
///
/// [`AuxPayload`] contains the processed auxiliary input data for a given subprotocol,
/// generated by resolving the corresponding [`AuxRequest`]s during the preprocessing phase.
/// The `id` field identifies which [`Subprotocol::ID`] this belongs to, and `data` contains
/// the processed auxiliary input as raw bytes.
///
/// Each [`AuxRequest`] must resolve into a corresponding [`AuxPayload`] before the main
/// processing phase can begin. The `data` field must deserialize into an instance of
/// [`Subprotocol::AuxInput`] for the associated subprotocol.
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct AuxPayload {
    /// Which subprotocol this payload belongs to.
    pub id: SubprotocolId,

    /// Processed auxiliary input data as raw bytes.
    ///
    /// This `Vec<u8>` must deserialize into one
    /// `<P as Subprotocol>::AuxInput` for the corresponding subprotocol P.
    pub data: Vec<u8>,
}

impl AuxPayload {
    pub fn new(id: SubprotocolId, data: Vec<u8>) -> Self {
        Self { id, data }
    }

    pub fn data(&self) -> &[u8] {
        &self.data
    }

    pub fn try_to_aux_input<S: Subprotocol>(&self) -> Result<S::AuxInput, AsmError> {
        if S::ID != self.id {
            return Err(Mismatched {
                expected: S::ID,
                actual: self.id,
            }
            .into());
        }
        <S::AuxInput as BorshDeserialize>::try_from_slice(&self.data)
            .map_err(|e| AsmError::Deserialization(self.id, e))
    }
}
