use borsh::{BorshDeserialize, BorshSerialize};
use strata_l1_txfmt::SubprotocolId;

use crate::{AsmError, Mismatched, Subprotocol};

/// A single auxiliary input request from a subprotocol during preprocessing.
///
/// [`AuxRequest`] represents a request made by a subprotocol during its
/// [`pre_process_txs`](Subprotocol::pre_process_txs) phase. Each request
/// contains the subprotocol's ID and the raw data needed for auxiliary
/// processing. These requests are collected and eventually resolved into
/// [`AuxPayload`] entries that can be used during the main processing phase.
///
/// The `data` field contains the raw bytes that will be processed to generate
/// the corresponding auxiliary input data in the final [`AuxPayload`].
#[derive(Debug)]
pub struct AuxRequest {
    /// Which subprotocol this request belongs to.
    pub id: SubprotocolId,
    /// Raw data for the auxiliary input request.
    pub data: Vec<u8>,
}

/// A single subprotocol's auxiliary input payload, containing processed auxiliary data.
///
/// [`AuxPayload`] contains the processed auxiliary input data for a given subprotocol,
/// generated by resolving the corresponding [`AuxRequest`]s during the preprocessing phase.
/// The `id` field identifies which [`Subprotocol::ID`] this belongs to, and `data` contains
/// the processed auxiliary input as raw bytes.
///
/// Each [`AuxRequest`] must resolve into a corresponding [`AuxPayload`] before the main
/// processing phase can begin. The `data` field must deserialize into an instance of
/// [`Subprotocol::AuxInput`] for the associated subprotocol.
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct AuxPayload {
    /// Which subprotocol this payload belongs to.
    pub id: SubprotocolId,

    /// Processed auxiliary input data as raw bytes.
    ///
    /// This `Vec<u8>` must deserialize into one
    /// `<P as Subprotocol>::AuxInput` for the corresponding subprotocol P.
    pub data: Vec<u8>,
}

impl AuxPayload {
    pub fn new(id: SubprotocolId, data: Vec<u8>) -> Self {
        Self { id, data }
    }

    pub fn try_to_aux_input<S: Subprotocol>(&self) -> Result<S::AuxInput, AsmError> {
        if S::ID != self.id {
            return Err(Mismatched {
                expected: S::ID,
                actual: self.id,
            }
            .into());
        }
        <S::AuxInput as BorshDeserialize>::try_from_slice(&self.data)
            .map_err(|e| AsmError::Deserialization(self.id, e))
    }
}

/// A bundle of auxiliary input payloads for a specific L1 block.
///
/// [`AuxBundle`] collects all of the [`AuxPayload`]s produced by resolving
/// the [`AuxRequest`]s from each subprotocol during their `pre_process_txs`
/// phase for one particular L1 block. Each subprotocol can have multiple
/// auxiliary input payloads, which are organized by subprotocol ID.
///
/// You can use this bundle to look up, decode, and feed each protocol's
/// auxiliary inputs into their respective `process_txs` methods.
#[derive(Debug, Clone, Default, BorshSerialize, BorshDeserialize)]
pub struct AuxBundle {
    /// All auxiliary input payloads organized by subprotocol ID.
    ///
    /// Each entry maps a [`SubprotocolId`] to a vector of [`AuxPayload`]s
    /// for that specific subprotocol. Multiple payloads per subprotocol
    /// are supported to handle cases where a subprotocol generates multiple
    /// auxiliary inputs during preprocessing.
    pub entries: Vec<(SubprotocolId, Vec<AuxPayload>)>,
}

impl AuxBundle {
    /// Gets all payloads for a specific subprotocol ID.
    pub fn find_payloads(&self, id: SubprotocolId) -> Option<&Vec<AuxPayload>> {
        self.entries
            .iter()
            .find(|(subprotocol_id, _)| *subprotocol_id == id)
            .map(|(_, payloads)| payloads)
    }

    /// Gets the first payload for a specific subprotocol ID.
    pub fn find_payload(&self, id: SubprotocolId) -> Option<&AuxPayload> {
        self.find_payloads(id)?.first()
    }

    /// Adds a payload for a specific subprotocol.
    pub fn add_payload(&mut self, id: SubprotocolId, payload: AuxPayload) {
        if let Some((_, payloads)) = self
            .entries
            .iter_mut()
            .find(|(subprotocol_id, _)| *subprotocol_id == id)
        {
            payloads.push(payload);
        } else {
            self.entries.push((id, vec![payload]));
        }
    }
}
