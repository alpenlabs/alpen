//! Auxiliary data request and response types.
//!
//! Defines the types of auxiliary data that subprotocols can request during
//! the pre-processing phase, and the corresponding response structures that
//! workers use to fulfill those requests.

use borsh::{BorshDeserialize, BorshSerialize};
use strata_asm_common::{AsmManifestCompactMmr, AsmManifestHash};

use crate::types::ManifestMmrProof;

/// Request for manifest leaves over an inclusive range.
///
/// Carries the compact manifest MMR snapshot so the resolver can
/// expand it and verify the included MMR proofs for each leaf.
#[derive(Clone, Debug, PartialEq, Eq, BorshSerialize, BorshDeserialize)]
pub struct ManifestLeavesRequest {
    /// Starting L1 block height (inclusive)
    pub start_height: u64,
    /// Ending L1 block height (inclusive)
    pub end_height: u64,
    /// Compact manifest MMR snapshot used for proof verification
    pub manifest_mmr: AsmManifestCompactMmr,
}

/// Request for a single Bitcoin transaction by txid.
#[derive(Clone, Debug, PartialEq, Eq, BorshSerialize, BorshDeserialize)]
pub struct BitcoinTxRequest {
    /// The Bitcoin transaction ID to fetch (32 bytes)
    pub txid: [u8; 32],
}

/// Response containing manifest leaves for a contiguous block range.
///
/// This is the data format sent over the wire. Only the leaves are included
/// in the response; proofs are generated by workers and verified by the resolver.
#[derive(Clone, Debug, PartialEq, Eq, BorshSerialize, BorshDeserialize)]
pub struct ManifestLeavesResponse {
    /// One manifest hash per block in range, ordered by height
    pub leaves: Vec<AsmManifestHash>,
}

/// Manifest leaves with their proofs for a contiguous block range.
///
/// This is used by the resolver to perform MMR verification.
/// It contains both the leaves and their corresponding proofs, but
/// does not imply prior verification.
///
/// Note: For now we include a separate Merkle proof for each leaf. Since the
/// leaves are contiguous within the range, this could be optimized to use a
/// single proof (or a more compact multi-proof) covering all leaves.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct ManifestLeavesWithProofs {
    /// One manifest hash per block in range, ordered by height
    pub leaves: Vec<AsmManifestHash>,
    /// Per-leaf MMR proofs (same order as `leaves`)
    pub proofs: Vec<ManifestMmrProof>,
}
