//! Build script for ASM specification configuration generation.
//!
//! This script generates compile-time configuration for the ASM (Application-Specific Module)
//! specification by reading rollup parameters from `rollup_params.json` and generating
//! appropriate Rust code.
//!
//! # Configuration Source
//!
//! The build script requires `rollup_params.json` generated by `datatool genparams`.
//! No fallback configuration is provided - the build will fail if no valid rollup_params.json is
//! found.
//!
//! # Search Order for rollup_params.json
//!
//! The script searches for rollup_params.json in the following order:
//! 1. Current directory (`./rollup_params.json`)
//! 2. Workspace root (`../../../rollup_params.json`)
//! 3. Functional tests directory (`../../../functional-tests/_dd/latest/rollup_params.json`)
//! 4. Path specified by `ROLLUP_PARAMS_PATH` environment variable
//!
//! # Usage
//!
//! 1. Generate rollup parameters using datatool: ```bash strata-datatool genparams -n "ALPN" [...]
//!    -o rollup_params.json ```
//!
//! 2. Build the ASM spec crate: ```bash cargo build -p strata-asm-spec ```
//!
//! # Generated Configuration
//!
//! The script generates a `generated.rs` file containing:
//! - `MAGIC_BYTES`: 4-byte rollup identifier from `rollup_name`
//! - `core_genesis` module with genesis configuration functions:
//!   - `checkpoint_vk()`: Verifying key for checkpoint proofs (TODO: parse from rollup_vk)
//!   - `genesis_l1_block()`: L1 block commitment for genesis
//!   - `sequencer_pubkey()`: Sequencer public key from credential rules
//! - `bridge_genesis` module (placeholder for future bridge configuration)
//!
//! # Configuration Mapping
//!
//! | rollup_params.json field | Generated constant/function | Purpose |
//! |--------------------------|------------------------------|---------|
//! | `rollup_name` (4 chars)  | `MAGIC_BYTES`               | Protocol identifier |
//! | `cred_rule.schnorr_key`  | `sequencer_pubkey()`        | Sequencer authorization |
//! | `genesis_l1_height`      | `genesis_l1_block()`        | Genesis block reference |
//! | `rollup_vk`              | `checkpoint_vk()` (TODO)    | Proof verification |
//!
//! # Validation
//!
//! All configuration values are validated at build time:
//! - Rollup name must be exactly 4 characters (for magic bytes)
//! - Sequencer key must be 32 bytes (64 hex characters) when using SchnorrKey credentials
//! - Genesis L1 height must be greater than 0
//! - JSON structure must match the expected `RollupParams` format

use std::{
    env, fs,
    path::{Path, PathBuf},
};

use strata_primitives::params::RollupParams;

// =============================================================================
// Constants
// =============================================================================

/// Default sequencer pubkey used in unchecked mode
const DEFAULT_SEQUENCER_PUBKEY: &str =
    "76849911e8c3bb3d55c9f9cedec8f9e5621fcc4aa791bd1f10369ee435b56b1f";

/// Default L1 block ID (all zeros) - not available in rollup_params.json
const DEFAULT_L1_BLOCK_ID: &str =
    "0000000000000000000000000000000000000000000000000000000000000000";

// =============================================================================
// Main Build Script Entry Point
// =============================================================================

fn main() {
    setup_cargo_configuration();

    // Allow CI to build without rollup_params.json by setting STRATA_CI_BUILD=1
    if env::var("STRATA_CI_BUILD").is_ok() {
        eprintln!("CI build detected - using minimal default configuration");
        generate_ci_configuration();
        return;
    }

    let rollup_params_path = find_rollup_params_file().unwrap_or_else(|| {
        panic!(
            "rollup_params.json not found. Please generate it first using:\n\
                 strata-datatool genparams -n \"ALPN\" [...] -o rollup_params.json\n\
                 \nSearched in:\n\
                 - ./rollup_params.json\n\
                 - ../../../rollup_params.json\n\
                 - ../../../functional-tests/_dd/latest/rollup_params.json\n\
                 - ROLLUP_PARAMS_PATH environment variable\n\
                 \nFor CI builds, set STRATA_CI_BUILD=1 to use minimal defaults\n"
        )
    });

    generate_from_rollup_params(rollup_params_path);
}

// =============================================================================
// Configuration Setup
// =============================================================================

/// Set up Cargo configuration for conditional compilation
fn setup_cargo_configuration() {
    // Declare known cfg values for conditional compilation
    println!("cargo:rustc-check-cfg=cfg(rollup_config_source, values(\"file\", \"ci\"))");
}

// =============================================================================
// File Discovery
// =============================================================================

/// Find rollup_params.json file in various standard locations.
///
/// Searches in order of preference:
/// 1. Current directory (for direct usage)
/// 2. Workspace root (for workspace-wide configuration)
/// 3. Functional tests directory (for development/testing)
/// 4. Environment variable path (for custom deployments)
///
/// Returns the path to the first rollup_params.json file found, or None.
fn find_rollup_params_file() -> Option<PathBuf> {
    let search_paths = get_rollup_params_search_paths();

    // Search in predefined locations
    for path_str in &search_paths {
        let path = Path::new(path_str);
        if path.exists() && path.is_file() {
            return Some(path.to_path_buf());
        }
    }

    // Check environment variable as fallback
    check_environment_path()
}

/// Get list of standard search paths for rollup_params.json
fn get_rollup_params_search_paths() -> [&'static str; 3] {
    [
        "./rollup_params.json",                                    // Current directory
        "../../../rollup_params.json",                             // Workspace root
        "../../../functional-tests/_dd/latest/rollup_params.json", // Functional tests
    ]
}

/// Check if ROLLUP_PARAMS_PATH environment variable points to a valid file
fn check_environment_path() -> Option<PathBuf> {
    if let Ok(env_path) = env::var("ROLLUP_PARAMS_PATH") {
        let path = Path::new(&env_path);
        if path.exists() && path.is_file() {
            return Some(path.to_path_buf());
        }
    }
    None
}

// =============================================================================
// Configuration Generation from rollup_params.json
// =============================================================================

/// Generate configuration from a rollup_params.json file
fn generate_from_rollup_params(params_path: PathBuf) {
    println!("cargo:rerun-if-changed={}", params_path.display());

    let params = load_and_parse_rollup_params(&params_path);
    validate_rollup_params(&params);

    let generated_code = generate_rust_code_from_rollup_params(&params);
    write_generated_code(&generated_code);

    // Set configuration flags
    println!("cargo:rustc-cfg=rollup_config_source=\"file\"");
    eprintln!("Using rollup_params.json from: {}", params_path.display());
}

/// Load and parse rollup_params.json file
fn load_and_parse_rollup_params(params_path: &Path) -> RollupParams {
    let params_content = fs::read_to_string(params_path).unwrap_or_else(|e| {
        panic!(
            "Failed to read rollup params file {}: {}",
            params_path.display(),
            e
        )
    });

    serde_json::from_str(&params_content).unwrap_or_else(|e| {
        panic!(
            "Failed to parse rollup params file {}: {}",
            params_path.display(),
            e
        )
    })
}

// =============================================================================
// CI Configuration Generation
// =============================================================================

/// Generate minimal configuration for CI builds
///
/// This provides just enough configuration to compile the crate without requiring
/// rollup_params.json. This should only be used for CI builds that check compilation
/// but don't actually use the generated configuration values.
fn generate_ci_configuration() {
    let generated_code = generate_ci_rust_code();
    write_generated_code(&generated_code);

    // Set configuration flags
    println!("cargo:rustc-cfg=rollup_config_source=\"ci\"");
    eprintln!("Generated minimal CI configuration");
}

/// Generate minimal Rust code for CI builds
fn generate_ci_rust_code() -> String {
    r#"
// Generated by build.rs for CI build - DO NOT USE IN PRODUCTION
// This is a minimal configuration that allows compilation but should not be used at runtime

pub const MAGIC_BYTES: [u8; 4] = [67, 73, 66, 68]; // "CIBD" (CI Build)

pub mod core_genesis {
    use strata_primitives::{buf::Buf32, l1::{L1BlockCommitment, L1BlockId}};
    use zkaleido::VerifyingKey;
    
    /// CI-only placeholder verifying key - DO NOT USE IN PRODUCTION
    pub fn checkpoint_vk() -> VerifyingKey {
        VerifyingKey::default()
    }
    
    /// CI-only placeholder L1 block commitment - DO NOT USE IN PRODUCTION
    pub fn genesis_l1_block() -> L1BlockCommitment {
        let block_id_hex = "0000000000000000000000000000000000000000000000000000000000000000";
        let block_id_bytes = hex::decode(block_id_hex)
            .expect("Failed to decode block ID hex");
        let mut block_id_array = [0u8; 32];
        block_id_array.copy_from_slice(&block_id_bytes);
        let buf32 = strata_primitives::buf::Buf32::from(block_id_array);
        let block_id = L1BlockId::from(buf32);
        
        L1BlockCommitment::new(1, block_id)
    }
    
    /// CI-only placeholder sequencer pubkey - DO NOT USE IN PRODUCTION
    pub fn sequencer_pubkey() -> Buf32 {
        let pubkey_hex = "0000000000000000000000000000000000000000000000000000000000000000";
        let pubkey_bytes = hex::decode(pubkey_hex)
            .expect("Failed to decode sequencer pubkey hex");
        let mut pubkey_array = [0u8; 32];
        pubkey_array.copy_from_slice(&pubkey_bytes);
        Buf32::from(pubkey_array)
    }
}

pub mod bridge_genesis {
    // CI placeholder for bridge configuration
}
"#
    .to_string()
}

// =============================================================================
// Validation
// =============================================================================

/// Validate rollup parameters for ASM compatibility
///
/// Ensures that the rollup parameters contain valid values for ASM configuration:
/// - Rollup name must be exactly 4 characters (for magic bytes)
/// - Sequencer key must be 32 bytes (64 hex characters) if present
/// - Genesis L1 height must be greater than 0
fn validate_rollup_params(params: &RollupParams) {
    validate_rollup_name(&params.rollup_name);
    validate_sequencer_credential(&params.cred_rule);
    validate_genesis_height(params.genesis_l1_height);
}

/// Validate rollup name for magic bytes generation
fn validate_rollup_name(rollup_name: &str) {
    if rollup_name.len() != 4 {
        panic!(
            "Rollup name must be exactly 4 characters for magic bytes, got: '{}' ({} chars)",
            rollup_name,
            rollup_name.len()
        );
    }
}

/// Validate sequencer credential configuration
fn validate_sequencer_credential(cred_rule: &strata_primitives::block_credential::CredRule) {
    if let strata_primitives::block_credential::CredRule::SchnorrKey(key) = cred_rule {
        let key_hex = hex::encode(key.0);
        if key_hex.len() != 64 {
            panic!(
                "Sequencer schnorr key must be 64 hex characters (32 bytes), got: {} characters",
                key_hex.len()
            );
        }
    }
}

/// Validate genesis L1 height
fn validate_genesis_height(height: u64) {
    if height == 0 {
        panic!("Genesis L1 height must be greater than 0, got: {}", height);
    }
}

// =============================================================================
// Code Generation
// =============================================================================

/// Generate Rust code from rollup parameters
fn generate_rust_code_from_rollup_params(params: &RollupParams) -> String {
    let config = extract_asm_config_from_rollup_params(params);

    format!(
        r#"
// Generated by build.rs from rollup_params.json - DO NOT EDIT
// Rollup: {rollup_name}
// Source: rollup_params.json

pub const MAGIC_BYTES: [u8; 4] = {magic_bytes_array};

pub mod core_genesis {{
    use strata_primitives::{{buf::Buf32, l1::{{L1BlockCommitment, L1BlockId}}}};
    use zkaleido::VerifyingKey;
    
    /// Returns the checkpoint verifying key for this rollup.
    /// 
    /// TODO: Parse the actual VK from rollup_params.rollup_vk
    /// The rollup_vk field contains the verifying key, but the format varies by ZKVM.
    /// For now, this returns a default VK for development/testing.
    pub fn checkpoint_vk() -> VerifyingKey {{
        VerifyingKey::default()
    }}
    
    /// Returns the L1 block commitment for genesis.
    /// 
    /// Uses the genesis_l1_height from rollup_params and a default block ID.
    /// The block ID is not specified in rollup_params, so we use all zeros.
    pub fn genesis_l1_block() -> L1BlockCommitment {{
        let block_id_hex = "{block_id}";
        let block_id_bytes = hex::decode(block_id_hex)
            .expect("Failed to decode block ID hex");
        let mut block_id_array = [0u8; 32];
        block_id_array.copy_from_slice(&block_id_bytes);
        let buf32 = strata_primitives::buf::Buf32::from(block_id_array);
        let block_id = L1BlockId::from(buf32);
        
        L1BlockCommitment::new({genesis_height}, block_id)
    }}
    
    /// Returns the sequencer public key for this rollup.
    /// 
    /// Extracted from the cred_rule field in rollup_params.
    /// For SchnorrKey credentials, uses the schnorr_key value.
    /// For Unchecked credentials, uses a default development key.
    pub fn sequencer_pubkey() -> Buf32 {{
        let pubkey_hex = "{sequencer_pubkey}";
        let pubkey_bytes = hex::decode(pubkey_hex)
            .expect("Failed to decode sequencer pubkey hex");
        let mut pubkey_array = [0u8; 32];
        pubkey_array.copy_from_slice(&pubkey_bytes);
        Buf32::from(pubkey_array)
    }}
}}

pub mod bridge_genesis {{
    // Future bridge configuration will be generated here
    // This will include bridge-specific genesis parameters when implemented
}}
"#,
        rollup_name = config.rollup_name,
        magic_bytes_array = config.magic_bytes_array,
        block_id = config.block_id,
        genesis_height = config.genesis_height,
        sequencer_pubkey = config.sequencer_pubkey
    )
}

// =============================================================================
// Configuration Extraction
// =============================================================================

/// Configuration extracted from rollup parameters for ASM generation
#[derive(Debug)]
struct AsmConfig {
    rollup_name: String,
    magic_bytes_array: String,
    block_id: String,
    genesis_height: u64,
    sequencer_pubkey: String,
}

/// Extract ASM-specific configuration from rollup parameters
fn extract_asm_config_from_rollup_params(params: &RollupParams) -> AsmConfig {
    let magic_bytes = params.rollup_name.as_bytes();
    let magic_bytes_array = format!(
        "[{}, {}, {}, {}]",
        magic_bytes[0], magic_bytes[1], magic_bytes[2], magic_bytes[3]
    );

    let sequencer_pubkey = extract_sequencer_pubkey(&params.cred_rule);

    AsmConfig {
        rollup_name: params.rollup_name.clone(),
        magic_bytes_array,
        block_id: DEFAULT_L1_BLOCK_ID.to_string(),
        genesis_height: params.genesis_l1_height,
        sequencer_pubkey,
    }
}

/// Extract sequencer public key from credential rule
fn extract_sequencer_pubkey(cred_rule: &strata_primitives::block_credential::CredRule) -> String {
    match cred_rule {
        strata_primitives::block_credential::CredRule::SchnorrKey(key) => hex::encode(key.0),
        strata_primitives::block_credential::CredRule::Unchecked => {
            // Use default pubkey for unchecked mode
            DEFAULT_SEQUENCER_PUBKEY.to_string()
        }
    }
}

// =============================================================================
// Output Generation
// =============================================================================

/// Write generated code to the output directory
fn write_generated_code(generated_code: &str) {
    let out_dir = env::var_os("OUT_DIR").expect("OUT_DIR environment variable not set");
    let dest_path = Path::new(&out_dir).join("generated.rs");

    fs::write(&dest_path, generated_code).unwrap_or_else(|e| {
        panic!(
            "Failed to write generated code to {}: {}",
            dest_path.display(),
            e
        )
    });
}
