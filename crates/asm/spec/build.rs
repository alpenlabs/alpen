use std::env;
use std::fs;
use std::path::Path;

use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize)]
struct AsmConfig {
    magic_bytes: String,
    core_genesis: CoreGenesisConfig,
    bridge_genesis: BridgeGenesisConfig,
}

#[derive(Debug, Deserialize, Serialize)]
struct CoreGenesisConfig {
    checkpoint_vk_file: String,
    genesis_l1_block: L1BlockConfig,
    sequencer_pubkey: String,
}

#[derive(Debug, Deserialize, Serialize)]
struct L1BlockConfig {
    height: u64,
    block_id: String,
}

#[derive(Debug, Deserialize, Serialize)]
struct BridgeGenesisConfig {
    #[serde(default)]
    note: Option<String>,
}

fn main() {
    // Declare known cfg values
    println!("cargo:rustc-check-cfg=cfg(asm_config_env, values(\"dev\", \"testnet\", \"mainnet\"))");
    
    println!("cargo:rerun-if-changed=asm_config.json");
    
    // Determine which config file to use based on environment
    let config_env = env::var("ASM_CONFIG_ENV").unwrap_or_else(|_| "dev".to_string());
    let config_file = match config_env.as_str() {
        "testnet" => "asm_config.testnet.json",
        "mainnet" => "asm_config.mainnet.json",
        _ => "asm_config.json",
    };
    
    println!("cargo:rerun-if-changed={}", config_file);
    
    // Read and parse configuration
    let config_path = Path::new(config_file);
    let config_content = fs::read_to_string(config_path)
        .unwrap_or_else(|e| panic!("Failed to read config file {}: {}", config_file, e));
    
    let config: AsmConfig = serde_json::from_str(&config_content)
        .unwrap_or_else(|e| panic!("Failed to parse config file {}: {}", config_file, e));
    
    // Validate configuration
    validate_config(&config);
    
    // Generate Rust code
    let out_dir = env::var_os("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("generated.rs");
    
    let generated_code = generate_rust_code(&config);
    fs::write(&dest_path, generated_code)
        .unwrap_or_else(|e| panic!("Failed to write generated code: {}", e));
    
    println!("cargo:rustc-cfg=asm_config_env=\"{}\"", config_env);
}

fn validate_config(config: &AsmConfig) {
    // Validate magic bytes
    if config.magic_bytes.len() != 4 {
        panic!("Magic bytes must be exactly 4 characters, got: {}", config.magic_bytes);
    }
    
    // Validate sequencer pubkey
    if config.core_genesis.sequencer_pubkey.len() != 64 {
        panic!("Sequencer pubkey must be 64 hex characters, got: {}", config.core_genesis.sequencer_pubkey);
    }
    
    // Validate block ID
    if config.core_genesis.genesis_l1_block.block_id.len() != 64 {
        panic!("Block ID must be 64 hex characters, got: {}", config.core_genesis.genesis_l1_block.block_id);
    }
    
    // Validate that checkpoint VK file exists
    let vk_path = Path::new(&config.core_genesis.checkpoint_vk_file);
    if !vk_path.exists() {
        panic!("Checkpoint VK file does not exist: {}", config.core_genesis.checkpoint_vk_file);
    }
}

fn generate_rust_code(config: &AsmConfig) -> String {
    let magic_bytes = config.magic_bytes.as_bytes();
    let magic_bytes_array = format!("[{}, {}, {}, {}]", magic_bytes[0], magic_bytes[1], magic_bytes[2], magic_bytes[3]);
    
    // Read and parse the verifying key file
    let vk_content = fs::read_to_string(&config.core_genesis.checkpoint_vk_file)
        .unwrap_or_else(|e| panic!("Failed to read VK file {}: {}", config.core_genesis.checkpoint_vk_file, e));
    
    // Write VK content to a separate file to avoid escaping issues
    let out_dir = env::var_os("OUT_DIR").unwrap();
    let vk_path = Path::new(&out_dir).join("checkpoint_vk.json");
    fs::write(&vk_path, &vk_content)
        .expect("Failed to write checkpoint VK file");
    
    format!(r#"
// Generated by build.rs - DO NOT EDIT
// Configuration environment: {}

pub const MAGIC_BYTES: [u8; 4] = {};

pub mod core_genesis {{
    use strata_primitives::{{buf::Buf32, l1::{{L1BlockCommitment, L1BlockId}}}};
    use zkaleido::VerifyingKey;
    
    pub fn checkpoint_vk() -> VerifyingKey {{
        // TODO: Parse the actual VK from JSON once we understand the correct format
        // For now, use a default VK to demonstrate the config system
        VerifyingKey::default()
    }}
    
    pub fn genesis_l1_block() -> L1BlockCommitment {{
        let block_id_hex = "{}";
        let block_id_bytes = hex::decode(block_id_hex)
            .expect("Failed to decode block ID hex");
        let mut block_id_array = [0u8; 32];
        block_id_array.copy_from_slice(&block_id_bytes);
        let buf32 = strata_primitives::buf::Buf32::from(block_id_array);
        let block_id = L1BlockId::from(buf32);
        
        L1BlockCommitment::new({}, block_id)
    }}
    
    pub fn sequencer_pubkey() -> Buf32 {{
        let pubkey_hex = "{}";
        let pubkey_bytes = hex::decode(pubkey_hex)
            .expect("Failed to decode sequencer pubkey hex");
        let mut pubkey_array = [0u8; 32];
        pubkey_array.copy_from_slice(&pubkey_bytes);
        Buf32::from(pubkey_array)
    }}
}}

pub mod bridge_genesis {{
    // Future bridge configuration will be generated here
}}
"#,
        env::var("ASM_CONFIG_ENV").unwrap_or_else(|_| "dev".to_string()),
        magic_bytes_array,
        config.core_genesis.genesis_l1_block.block_id,
        config.core_genesis.genesis_l1_block.height,
        config.core_genesis.sequencer_pubkey
    )
}