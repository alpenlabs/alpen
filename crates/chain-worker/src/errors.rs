use strata_primitives::prelude::*;
use thiserror::Error;
use tracing::*;

/// Return type for worker messages.
pub type WorkerResult<T> = Result<T, WorkerError>;

#[derive(Debug, Error)]
pub enum WorkerError {
    #[error("missing block {0}")]
    MissingL2Block(L2BlockId),

    /// This usually means that we didn't execute the previous block.
    #[error("missing pre-state to execute block {0:?}")]
    MissingPreState(L2BlockCommitment),

    /// This might point to a database corruption or misused admin commands.
    /// The worker should not have tried to access block outputs that are
    /// missing.
    #[error("missing exec output for block {0:?}")]
    MissingBlockOutput(L2BlockCommitment),

    /// This means that we haven't executed the block that's the terminal for an epoch.
    #[error("missing inner post-state of epoch {0} terminal {1:?}")]
    MissingEpochInnerPostState(u64, L2BlockCommitment),

    #[error("invalid execution payload for block {0:?}")]
    InvalidExecPayload(L2BlockCommitment),

    #[error("missing summary for epoch commitment {0:?}")]
    MissingEpochSummary(EpochCommitment),

    /// Generated by the worker handle when the worker has exited before being
    /// able to process a message we were trying to send.
    #[error("chain worker exited")]
    WorkerExited,

    #[error("OL block execution: {0}")]
    Exec(#[from] strata_chainexec::Error),

    #[error("EE block execution: {0}")]
    ExecEnvEngine(#[from] strata_eectl::errors::EngineError),

    #[error("missing required dependency: {0}")]
    MissingDependency(&'static str),

    #[error("shutdown before genesis")]
    ShutdownBeforeGenesis,

    #[error("worker not initialized")]
    NotInitialized,

    #[error("unexpected error: {0}")]
    Unexpected(String),

    #[error("not yet implemented")]
    Unimplemented,
}

/// Weird impl that we need to go "back down" for context fns.
// TODO maybe restructure error types so we don't need this?
impl From<WorkerError> for strata_chainexec::Error {
    fn from(err: WorkerError) -> Self {
        use strata_chainexec::Error as ExecError;
        // TODO improve these relationships, they're kinda backwards in places
        match err {
            WorkerError::MissingL2Block(block) => ExecError::MissingL2Header(block),
            WorkerError::MissingPreState(block) => ExecError::MissingBlockPreState(*block.blkid()),
            WorkerError::MissingBlockOutput(block) => {
                ExecError::MissingBlockPostState(*block.blkid())
            }
            WorkerError::MissingEpochInnerPostState(_, block) => {
                ExecError::MissingBlockPostState(*block.blkid())
            }
            WorkerError::MissingEpochSummary(epoch) => {
                // you may still want to log a warning here
                warn!(?epoch, "worker error: missing epoch summary");
                ExecError::Unimplemented
            }
            WorkerError::Exec(e) => e,
            WorkerError::WorkerExited | WorkerError::InvalidExecPayload(_) => {
                ExecError::Unexpected("exec worker error".to_owned())
            }
            WorkerError::MissingDependency(dep) => {
                ExecError::Unexpected(format!("missing dependency: {dep}"))
            }
            WorkerError::ShutdownBeforeGenesis => {
                ExecError::Unexpected("shutdown before genesis".to_owned())
            }
            WorkerError::NotInitialized => {
                ExecError::Unexpected("worker not initialized".to_owned())
            }
            WorkerError::Unexpected(msg) => ExecError::Unexpected(msg),
            WorkerError::Unimplemented => ExecError::Unimplemented,
            WorkerError::ExecEnvEngine(_) => ExecError::Unimplemented, // FIXME:
        }
    }
}
