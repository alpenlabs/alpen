use alpen_ee_node::account_state::{Account, AccountStateCommitment};
use alpen_ee_primitives::EEBlockHash;

use crate::{block::BlockPackage, message::OutboundMsgEnvelope};

#[derive(Debug, Clone)]
#[allow(unused)]
pub struct Proof {
    // TODO: correct type
    raw: Vec<u8>,
}

/// Unique identifier for a specific batch for updates or proving
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BatchId {
    start: EEBlockHash,
    end: EEBlockHash,
}

/// Represent a batch of blocks that are part of a single proving operation and update to OL
#[derive(Debug, Clone)]
pub struct Batch {
    idx: u64,
    start: EEBlockHash,
    end: EEBlockHash,
    proof: Option<Proof>,
}

impl Batch {
    pub fn new_unproven(idx: u64, start: EEBlockHash, end: EEBlockHash) -> Self {
        Self {
            idx,
            start,
            end,
            proof: None,
        }
    }

    pub fn with_proof(&mut self, proof: Proof) -> &mut Self {
        self.proof = Some(proof);
        self
    }

    pub fn idx(&self) -> u64 {
        self.idx
    }

    pub fn start(&self) -> &EEBlockHash {
        &self.start
    }

    pub fn end(&self) -> &EEBlockHash {
        &self.end
    }

    pub fn proof(&self) -> &Option<Proof> {
        &self.proof
    }
}

/// EE state update with proof sent to OL by EE sequencer
/// Will correspond 1-1 to a batch
#[derive(Debug, Clone)]
pub struct EEUpdate {
    /// update sequence no. Must equal expected sequence number in account
    sequencer_no: u64,
    /// expected current account state before update
    pre_state: AccountStateCommitment, // maybe unnecessary
    /// account state after update
    post_state: AccountStateCommitment,
    /// outbound messages generated by this update
    outbound_messages: Vec<OutboundMsgEnvelope>,
    /// number of inbound messages consumed in this update
    inbound_messages_consumed: u64,
    /// proof attesting to correctness of this update
    proof: Proof,
}

impl EEUpdate {
    pub fn sequence_no(&self) -> u64 {
        self.sequencer_no
    }

    pub fn pre_state(&self) -> &AccountStateCommitment {
        &self.pre_state
    }

    pub fn post_state(&self) -> &AccountStateCommitment {
        &self.post_state
    }

    pub fn outbound_messages(&self) -> &Vec<OutboundMsgEnvelope> {
        &self.outbound_messages
    }

    pub fn inbound_messages_consumed(&self) -> u64 {
        self.inbound_messages_consumed
    }

    pub fn proof(&self) -> &Proof {
        &self.proof
    }
}

pub fn new_ee_update_unchecked(
    cur_account_state: &Account,
    batch: &Batch,
    packages: &[BlockPackage],
) -> EEUpdate {
    let sequencer_no = cur_account_state.sequence_no();
    let pre_state = cur_account_state.state().clone();
    let post_state = batch.end.into();
    let (outbound_messages, inbound_messages_consumed) = packages.iter().fold(
        (Vec::new(), 0),
        |(mut outbound_messages, mut inbound_messages_consumed), package| {
            outbound_messages.extend_from_slice(package.output_msg());
            inbound_messages_consumed += package.input_msgs().len() as u64;

            (outbound_messages, inbound_messages_consumed)
        },
    );
    let proof = batch.proof.clone().unwrap();

    EEUpdate {
        sequencer_no,
        pre_state,
        post_state,
        outbound_messages,
        inbound_messages_consumed,
        proof,
    }
}
