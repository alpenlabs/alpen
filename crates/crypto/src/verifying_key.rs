use borsh::{BorshDeserialize, BorshSerialize};
use serde::{Deserialize, Serialize};
use zkaleido_risc0_groth16_verifier::Risc0Groth16Verifier;
use zkaleido_sp1_groth16_verifier::SP1Groth16Verifier;

/// Represents the verifying key used for verifying ZK proofs in a rollup context.
///
/// This enum encapsulates verifying keys for different ZKVMs:
/// - `SP1VerifyingKey`: Used for verifying proofs generated using SP1.
/// - `Risc0VerifyingKey`: Used for verifying proofs generated using Risc0.
/// - `Native`: For functional testing purposes without ZKVM overhead.
#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum RollupVerifyingKey {
    /// Verifying Key for proofs generated by SP1.
    #[serde(rename = "sp1")]
    SP1VerifyingKey(SP1Groth16Verifier),

    /// Verifying Key for proofs generated by Risc0.
    #[serde(rename = "risc0")]
    Risc0VerifyingKey(Risc0Groth16Verifier),

    /// Placeholder variant for functional testing.
    ///
    /// This variant allows skipping guest code compilation (e.g., ELFs for SP1 or Risc0) and is
    /// used to test the prover-client and proof logic without the overhead of ZKVM
    /// compilation. It is strictly for internal testing and must not be used in production
    /// deployments.
    #[serde(rename = "native")]
    NativeVerifyingKey,
}

impl BorshSerialize for RollupVerifyingKey {
    fn serialize<W: std::io::Write>(&self, writer: &mut W) -> std::io::Result<()> {
        let encoded = bincode::serialize(self).map_err(std::io::Error::other)?;
        BorshSerialize::serialize(&encoded, writer)
    }
}

impl BorshDeserialize for RollupVerifyingKey {
    fn deserialize_reader<R: std::io::Read>(reader: &mut R) -> std::io::Result<Self> {
        let encoded = Vec::<u8>::deserialize_reader(reader)?;
        bincode::deserialize(&encoded).map_err(std::io::Error::other)
    }
}
