use std::fmt::Display;

use borsh::{BorshDeserialize, BorshSerialize};
use serde::{Deserialize, Serialize};
use zkaleido_sp1_groth16_verifier::SP1Groth16Verifier;

use crate::{EvmEeBlockCommitment, L2BlockCommitment};

pub type Epoch = u64;

/// Represents the verifying key used for verifying ZK proofs in a rollup context.
///
/// This enum encapsulates verifying keys for different ZKVMs:
/// - `SP1VerifyingKey`: Used for verifying proofs generated using SP1.
/// - `Native`: For functional testing purposes without ZKVM overhead.
// TODO: (PG) - replace RollupVerifyingKey with PredicateKey
#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
#[expect(
    clippy::large_enum_variant,
    reason = "Will be replaced with predicate key in the future"
)]
pub enum RollupVerifyingKey {
    /// Verifying Key for proofs generated by SP1.
    #[serde(rename = "sp1")]
    SP1VerifyingKey(SP1Groth16Verifier),

    /// Placeholder variant for functional testing.
    ///
    /// This variant allows skipping guest code compilation (e.g., ELFs for SP1) and is
    /// used to test the prover-client and proof logic without the overhead of ZKVM
    /// compilation. It is strictly for internal testing and must not be used in production
    /// deployments.
    #[serde(rename = "native")]
    NativeVerifyingKey,
}

impl BorshSerialize for RollupVerifyingKey {
    fn serialize<W: std::io::Write>(&self, writer: &mut W) -> std::io::Result<()> {
        let encoded = bincode::serialize(self).map_err(std::io::Error::other)?;
        BorshSerialize::serialize(&encoded, writer)
    }
}

impl BorshDeserialize for RollupVerifyingKey {
    fn deserialize_reader<R: std::io::Read>(reader: &mut R) -> std::io::Result<Self> {
        let encoded = Vec::<u8>::deserialize_reader(reader)?;
        bincode::deserialize(&encoded).map_err(std::io::Error::other)
    }
}

/// Represents a context for different types of proofs.
///
/// This enum categorizes proofs by their associated context, including the type of proof and its
/// range or scope. Each variant includes relevant metadata required to distinguish and track the
/// proof.
#[derive(
    Debug,
    Clone,
    Copy,
    PartialEq,
    Eq,
    Hash,
    BorshSerialize,
    BorshDeserialize,
    Serialize,
    Deserialize,
)]
pub enum ProofContext {
    /// Identifier for the EVM Execution Environment (EE) blocks used in generating the State
    /// Transition Function (STF) proof.
    EvmEeStf(EvmEeBlockCommitment, EvmEeBlockCommitment),

    /// Identifier for the Consensus Layer (CL) blocks used in generating the State Transition
    /// Function (STF) proof.
    ClStf(L2BlockCommitment, L2BlockCommitment),

    /// Identifier for a specific checkpoint being proven.
    Checkpoint(u64),
}

/// Represents the ZkVm host used for proof generation.
///
/// This enum identifies the ZkVm environment utilized to create a proof.
/// Available hosts:
/// - `SP1`: SP1 ZKVM.
/// - `Native`: Native ZKVM.
#[non_exhaustive]
#[derive(
    Debug,
    Clone,
    Copy,
    PartialEq,
    Eq,
    Hash,
    BorshSerialize,
    BorshDeserialize,
    Serialize,
    Deserialize,
)]
pub enum ProofZkVm {
    SP1,
    Native,
}

/// Represents a unique key for identifying any type of proof.
///
/// A `ProofKey` combines a `ProofContext` (which specifies the type of proof and its scope)
/// with a `ProofZkVm` (which specifies the ZKVM host used for proof generation).
#[derive(
    Debug,
    Clone,
    Copy,
    PartialEq,
    Eq,
    Hash,
    BorshSerialize,
    BorshDeserialize,
    Serialize,
    Deserialize,
)]
pub struct ProofKey {
    /// The unique identifier for the proof type and its context.
    context: ProofContext,
    /// The ZKVM host used for proof generation.
    host: ProofZkVm,
}

impl ProofKey {
    pub fn new(context: ProofContext, host: ProofZkVm) -> Self {
        Self { context, host }
    }

    pub fn context(&self) -> &ProofContext {
        &self.context
    }

    pub fn host(&self) -> &ProofZkVm {
        &self.host
    }
}

impl Display for ProofKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ProofKey(context = {:?}, host = {:?})",
            self.context, self.host
        )
    }
}
